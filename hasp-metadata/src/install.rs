// Copyright (c) The hasp Contributors
// SPDX-License-Identifier: MIT OR Apache-2.0

use crate::PackageDirectory;
use camino::Utf8PathBuf;
use chrono::{DateTime, Local};
use serde::{Deserialize, Serialize};
use std::borrow::Cow;

/// A message generated by hasp when an installation is started.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "kebab-case")]
pub struct InstallStarted {
    /// Information about the package being installed.
    pub package: PackageDirectory,

    /// The method of installation.
    pub method: InstallMethod,

    /// Whether this is a force installation, overwriting an existing install.
    pub force: bool,

    /// The time at which the installation was started.
    pub start_time: DateTime<Local>,

    /// The full path to the temporary directory to which the install is being performed.
    pub new_dir: Utf8PathBuf,

    /// If this is an update to the same directory, the full path to the temporary directory to
    /// which the previous install will been moved.
    pub old_dir: Utf8PathBuf,
    // TODO: namespace-specific metadata
}

/// An installation process succeeded.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "kebab-case")]
pub struct InstallSuccess {
    /// Information about the package being installed.
    pub package: PackageDirectory,

    /// The method of installation.
    pub method: InstallMethod,

    /// Whether this is a force installation, overwriting an existing install.
    pub force: bool,

    /// The time at which the installation was started.
    pub start_time: DateTime<Local>,

    /// The time at which the installation process ended.
    pub end_time: DateTime<Local>,
    // TODO: more specific metadata
}

/// An installation process failed.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "kebab-case")]
pub struct InstallFailed {
    /// Information about the package being installed.
    pub package: PackageDirectory,

    /// The method of installation.
    pub method: InstallMethod,

    /// Whether this is a force installation, overwriting an existing install.
    pub force: bool,

    /// The time at which the installation was started.
    pub start_time: DateTime<Local>,

    /// The time at which the installation process ended.
    pub end_time: DateTime<Local>,

    /// The reason the install failed.
    pub reason: InstallFailureReason,
}

/// The method of installation.
///
/// This represents a single method.
#[derive(Clone, Debug, Deserialize, Serialize, Eq, Hash, Ord, PartialOrd, PartialEq)]
#[serde(rename_all = "kebab-case", transparent)]
#[repr(transparent)]
pub struct InstallMethod(Cow<'static, str>);

impl InstallMethod {
    /// Method representing a local Cargo build.
    pub const CARGO_LOCAL: Self = Self::new_const("cargo-local");

    /// Creates a new `InstallMethod` from a static string.
    #[inline]
    pub const fn new_const(method: &'static str) -> Self {
        Self(Cow::Borrowed(method))
    }

    /// Creates a new `InstallMethod`.
    #[inline]
    pub fn new(method: impl Into<Cow<'static, str>>) -> Self {
        Self(method.into())
    }

    /// Returns the install method as a string.
    #[inline]
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

/// The reason a package installation failed.
///
/// This represents a single method.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "kebab-case", tag = "type")]
pub enum InstallFailureReason {
    /// The external installation process failed.
    ProcessFailed {
        /// Metadata associated with the failure.
        metadata: serde_json::Value,
    },

    /// The installation process was aborted due to an issue encountered by hasp.
    Aborted {
        /// Metadata associated with the abort.
        metadata: serde_json::Value,
    },
}

#[cfg(feature = "rusqlite")]
mod rusqlite_impls {
    use super::*;
    use rusqlite::{
        types::{FromSql, FromSqlResult, ToSqlOutput, ValueRef},
        ToSql,
    };

    impl FromSql for InstallMethod {
        fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
            let value = value.as_str()?;
            Ok(InstallMethod::new(value.to_owned()))
        }
    }

    impl ToSql for InstallMethod {
        fn to_sql(&self) -> rusqlite::Result<ToSqlOutput<'_>> {
            self.0.to_sql()
        }
    }
}
