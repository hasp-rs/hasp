<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Smart String"><meta name="keywords" content="rust, rustlang, rust-lang, smartstring"><title>smartstring - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../smartstring/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate smartstring</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.2.9</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all smartstring's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="smartstring" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">smartstring</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/smartstring/lib.rs.html#5-1223" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h1 id="smart-string" class="section-header"><a href="#smart-string">Smart String</a></h1>
<p><a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> is a wrapper around <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> which offers
automatic inlining of small strings. It comes in two flavours:
<a href="struct.LazyCompact.html" title="LazyCompact"><code>LazyCompact</code></a>, which takes up exactly as much space as a <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>
and is generally a little faster, and <a href="struct.Compact.html" title="Compact"><code>Compact</code></a>, which is the same as
<a href="struct.LazyCompact.html" title="LazyCompact"><code>LazyCompact</code></a> except it will aggressively re-inline any expanded
<a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>s which become short enough to do so.
<a href="struct.LazyCompact.html" title="LazyCompact"><code>LazyCompact</code></a> is the default.</p>
<h2 id="what-is-it-for" class="section-header"><a href="#what-is-it-for">What Is It For?</a></h2>
<p>The intended use for <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> is as a key type for a
B-tree (such as <a href="https://doc.rust-lang.org/1.56.0/alloc/collections/btree/map/struct.BTreeMap.html" title="std::collections::BTreeMap"><code>std::collections::BTreeMap</code></a>) or any kind of
array operation where cache locality is critical.</p>
<p>In general, it’s a nice data type for reducing your heap allocations and
increasing the locality of string data. If you use <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>
as a drop-in replacement for <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>, you’re almost certain to see
a slight performance boost, as well as slightly reduced memory usage.</p>
<h2 id="how-to-use-it" class="section-header"><a href="#how-to-use-it">How To Use It?</a></h2>
<p>Before using <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>, you should always call
<a href="fn.validate.html" title="validate"><code>smartstring::validate()</code></a>, to make sure <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> is safe to use.
Ideally, you should call it at the start of your <code>main()</code> function, and
from your test suite. <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> will also attempt to crash early if
inconsistencies are detected, but this isn’t foolproof.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">smartstring::validate</span>();
}</code></pre></div>
<p><a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> has the exact same API as <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>,
all the clever bits happen automatically behind the scenes, so you could just:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">smartstring::alias::String</span>;
<span class="kw">use</span> <span class="ident">std::fmt::Write</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">string</span> <span class="op">=</span> <span class="ident">String::new</span>();
<span class="ident">string</span>.<span class="ident">push_str</span>(<span class="string">&quot;This is just a string!&quot;</span>);
<span class="ident">string</span>.<span class="ident">clear</span>();
<span class="macro">write!</span>(<span class="ident">string</span>, <span class="string">&quot;Hello Joe!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello Joe!&quot;</span>, <span class="ident">string</span>);</code></pre></div>
<h2 id="give-me-the-details" class="section-header"><a href="#give-me-the-details">Give Me The Details</a></h2>
<p><a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> is the same size as <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> and
relies on pointer alignment to be able to store a discriminant bit in its
inline form that will never be present in its <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> form, thus
giving us 24 bytes (on 64-bit architectures) minus one bit to encode our
inline string. It uses 23 bytes to store the string data and the remaining
7 bits to encode the string’s length. When the available space is exceeded,
it swaps itself out with a <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> containing its previous
contents. Likewise, if the string’s length should drop below its inline
capacity again, it deallocates the string and moves its contents inline.</p>
<p>Given that we use the knowledge that a certain bit in the memory layout
of <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> will always be unset as a discriminant, you would be
able to call <a href="https://doc.rust-lang.org/1.56.0/core/intrinsics/fn.transmute.html" title="std::mem::transmute"><code>std::mem::transmute::&lt;String&gt;()</code></a> on a boxed
smart string and start using it as a normal <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> immediately -
there’s no pointer tagging or similar trickery going on here.
(But please don’t do that, there’s an efficient <a href="struct.SmartString.html#impl-Into%3CString%3E"><code>Into&lt;String&gt;</code></a>
implementation that does the exact same thing with no need to go unsafe
in your own code.)</p>
<p>In <a href="struct.Compact.html" title="Compact"><code>Compact</code></a> mode, it is aggressive about inlining strings, meaning that if you modify a heap allocated
string such that it becomes short enough for inlining, it will be inlined immediately
and the allocated <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> will be dropped. This may cause multiple
unintended allocations if you repeatedly adjust your string’s length across the
inline capacity threshold, so if your string’s construction can get
complicated and you’re relying on performance during construction, it might be better
to construct it as a <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> and convert it once construction is done.</p>
<p><a href="struct.LazyCompact.html" title="LazyCompact"><code>LazyCompact</code></a> looks the same as <a href="struct.Compact.html" title="Compact"><code>Compact</code></a>, except
it never re-inlines a string that’s already been heap allocated, instead
keeping the allocation around in case it needs it. This makes for less
cache local strings, but is the best choice if you’re more worried about
time spent on unnecessary allocations than cache locality.</p>
<h2 id="performance" class="section-header"><a href="#performance">Performance</a></h2>
<p>It doesn’t aim to be more performant than <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> in the general case,
except that it doesn’t trigger heap allocations for anything shorter than
its inline capacity and so can be reasonably expected to exceed
<a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>’s performance perceptibly on shorter strings, as well as being more
memory efficient in these cases. There will always be a slight overhead on all
operations on boxed strings, compared to <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a>.</p>
<h2 id="caveat" class="section-header"><a href="#caveat">Caveat</a></h2>
<p>The way <code>smartstring</code> gets by without a discriminant is dependent on the memory layout of the
<a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="std::string::String"><code>std::string::String</code></a> struct, which isn’t something the Rust compiler and standard library make any
guarantees about. <code>smartstring</code> makes an assumption about how it’s been laid out, which has held
basically since rustc came into existence, but is nonetheless not a safe assumption to make, and if
the layout ever changes, <code>smartstring</code> will stop working properly (at least on little-endian
architectures, the assumptions made on big-endian archs will hold regardless of the actual memory
layout). Its test suite does comprehensive validation of these assumptions, and as long as the
<a href="https://travis-ci.org/github/bodil/smartstring">CI build</a> is passing for any given rustc version,
you can be sure it will do its job properly on all tested architectures. More directly, as mentioned
above, you should always call <a href="fn.validate.html" title="validate"><code>smartstring::validate()</code></a> before using <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> to
remove any doubt.</p>
<p>As an extra precaution, some runtime checks are made as well, so that if the memory layout
assumption no longer holds, <code>smartstring</code> will not work correctly, but there should be no security
implications and it should crash early.</p>
<h2 id="feature-flags" class="section-header"><a href="#feature-flags">Feature Flags</a></h2>
<p><code>smartstring</code> comes with optional support for the following crates through Cargo
feature flags. You can enable them in your <code>Cargo.toml</code> file like this:</p>
<div class="example-wrap"><pre class="language-no_compile"><code>[dependencies]
smartstring = { version = &quot;*&quot;, features = [&quot;proptest&quot;, &quot;serde&quot;] }</code></pre></div><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/arbitrary"><code>arbitrary</code></a></td><td><a href="https://docs.rs/arbitrary/latest/arbitrary/trait.Arbitrary.html"><code>Arbitrary</code></a> implementation for <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>.</td></tr>
<tr><td><a href="https://crates.io/crates/proptest"><code>proptest</code></a></td><td>A strategy for generating <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>s from a regular expression.</td></tr>
<tr><td><a href="https://crates.io/crates/serde"><code>serde</code></a></td><td><a href="https://docs.rs/serde/latest/serde/trait.Serialize.html"><code>Serialize</code></a> and <a href="https://docs.rs/serde/latest/serde/trait.Deserialize.html"><code>Deserialize</code></a> implementations for <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>.</td></tr>
</tbody></table>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="alias/index.html" title="smartstring::alias mod">alias</a></div><div class="item-right docblock-short"><p>Convenient type aliases.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Compact.html" title="smartstring::Compact struct">Compact</a></div><div class="item-right docblock-short"><p>A compact string representation equal to <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> in size with guaranteed inlining.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Drain.html" title="smartstring::Drain struct">Drain</a></div><div class="item-right docblock-short"><p>A draining iterator for a <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.LazyCompact.html" title="smartstring::LazyCompact struct">LazyCompact</a></div><div class="item-right docblock-short"><p>A representation similar to <a href="struct.Compact.html" title="Compact"><code>Compact</code></a> but which doesn’t re-inline strings.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SmartString.html" title="smartstring::SmartString struct">SmartString</a></div><div class="item-right docblock-short"><p>A smart string.</p>
</div></div><h2 id="constants" class="section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="constant" href="constant.MAX_INLINE.html" title="smartstring::MAX_INLINE constant">MAX_INLINE</a></div><div class="item-right docblock-short"><p>The maximum capacity of an inline string, in bytes.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.SmartStringMode.html" title="smartstring::SmartStringMode trait">SmartStringMode</a></div><div class="item-right docblock-short"><p>Marker trait for <a href="struct.SmartString.html" title="SmartString"><code>SmartString</code></a> representations.</p>
</div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="fn" href="fn.validate.html" title="smartstring::validate fn">validate</a></div><div class="item-right docblock-short"><p>Validate the crate’s assumptions about <a href="https://doc.rust-lang.org/1.56.0/alloc/string/struct.String.html" title="String"><code>String</code></a> memory layout.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="smartstring" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>